# OpenChoreo Workload Descriptor
# This file defines how your workload exposes endpoints and connects to other services.
# It sits alongside your source code and gets converted to a Workload Custom Resource (CR).
apiVersion: openchoreo.dev/v1alpha1

# Basic metadata for the workload
metadata:
  # +required Name of the workload
  name: sample-microservice

# +optional Incoming connection details for the component
# Endpoints define the network interfaces that this workload exposes to other services
endpoints:
  # REST API endpoint example
  - # +required Unique name for the endpoint
    # This name will be used when generating the managed API and as the key in the CR map
    name: rest-api
    # +required Numeric port value that gets exposed via the endpoint
    port: 8080
    # +required Type of traffic that the endpoint is accepting
    # Allowed values: REST, GraphQL, gRPC, TCP, UDP, HTTP, Websocket
    type: REST
    # +optional The path to the schema definition file
    # This is applicable to REST, GraphQL, and gRPC endpoint types
    # The path should be relative to the workload.yaml file location
    schemaFile: openapi.yaml

  # GraphQL endpoint example
  - name: graphql-api
    port: 4000
    type: GraphQL
    # GraphQL schema file (typically .graphql or .gql)
    schemaFile: schema.graphql

  # gRPC endpoint example
  - name: grpc-api
    port: 9090
    type: gRPC
    # Protocol buffer definition file
    schemaFile: service.proto

  # TCP endpoint example (for raw TCP connections like Redis, databases)
  - name: tcp-endpoint
    port: 6379
    type: TCP
    # No schema file needed for TCP endpoints

  # UDP endpoint example (for UDP traffic like DNS, logging)
  - name: udp-endpoint
    port: 5353
    type: UDP
    # No schema file needed for UDP endpoints

# +optional Connection definitions
# Connections define how this workload consumes other services and resources
# Note: This array format gets converted to a map format in the Workload CR
connections:
  # Database connection example
  - # +required Unique name for the connection
    name: user-database
    # +required Type of the connection
    # Currently only "api" is supported, but future types may include:
    # database, message-broker, event-stream, file-system, object-storage, secret-store
    type: api
    # +required Parameters for the connection
    # These specify which service/component to connect to
    params:
      # Project where the target service is located
      projectName: microservices-demo
      # Component name of the target service
      componentName: postgres-db
      # Endpoint name on the target service to connect to
      endpoint: db-endpoint
    # +optional Environment variable injection configuration
    # Defines how connection details are injected into your container
    inject:
      env:
        # Full database connection string using template variables
        - name: DATABASE_URL
          # Template variables like {{ .username }}, {{ .password }}, etc. are resolved at runtime
          value: "postgresql://{{ .username }}:{{ .password }}@{{ .host }}:{{ .port }}/{{ .database }}"
        # Individual connection components
        - name: DB_HOST
          value: "{{ .host }}"
        - name: DB_PORT
          value: "{{ .port }}"
        - name: DB_USER
          value: "{{ .username }}"
        - name: DB_PASSWORD
          value: "{{ .password }}"
        - name: DB_NAME
          value: "{{ .database }}"

  # Redis cache connection example
  - name: redis-cache
    type: api
    params:
      projectName: microservices-demo
      componentName: redis
      endpoint: tcp-endpoint
    inject:
      env:
        # Redis connection in host:port format
        - name: REDIS_ADDR
          value: "{{ .host }}:{{ .port }}"
        # Redis URL format
        - name: CACHE_URL
          value: "redis://{{ .host }}:{{ .port }}"
        # Redis password if authentication is enabled
        - name: REDIS_PASSWORD
          value: "{{ .password }}"

  # Message broker connection example (RabbitMQ/Kafka)
  - name: message-queue
    type: api
    params:
      projectName: microservices-demo
      componentName: rabbitmq
      endpoint: amqp-endpoint
    inject:
      env:
        # Full AMQP connection string
        - name: RABBITMQ_URL
          value: "amqp://{{ .username }}:{{ .password }}@{{ .host }}:{{ .port }}/{{ .vhost }}"
        # Individual components for custom connection logic
        - name: QUEUE_HOST
          value: "{{ .host }}"
        - name: QUEUE_PORT
          value: "{{ .port }}"
        - name: QUEUE_USER
          value: "{{ .username }}"
        - name: QUEUE_PASS
          value: "{{ .password }}"
        - name: QUEUE_VHOST
          value: "{{ .vhost }}"

  # External API service connection example
  - name: payment-service
    type: api
    params:
      # External services might be in different projects
      projectName: external-services
      componentName: stripe-api
      endpoint: rest-api
    inject:
      env:
        # API endpoint URL
        - name: PAYMENT_API_URL
          value: "{{ .url }}"
        # API authentication key
        - name: PAYMENT_API_KEY
          value: "{{ .apiKey }}"
        # API version if applicable
        - name: PAYMENT_API_VERSION
          value: "{{ .version }}"

  # Object storage connection example (S3, MinIO, etc.)
  - name: file-storage
    type: api
    params:
      projectName: microservices-demo
      componentName: s3-bucket
      endpoint: s3-endpoint
    inject:
      env:
        # S3 bucket URL
        - name: S3_BUCKET_URL
          value: "{{ .bucketUrl }}"
        # S3 access credentials
        - name: S3_ACCESS_KEY
          value: "{{ .accessKey }}"
        - name: S3_SECRET_KEY
          value: "{{ .secretKey }}"
        # S3 region
        - name: S3_REGION
          value: "{{ .region }}"
        # S3 bucket name
        - name: S3_BUCKET_NAME
          value: "{{ .bucketName }}"

  # Another microservice connection example
  - name: user-service
    type: api
    params:
      projectName: microservices-demo
      componentName: user-management
      endpoint: rest-api
    inject:
      env:
        # Service URL for making HTTP requests
        - name: USER_SERVICE_URL
          value: "{{ .url }}"
        # Service authentication token
        - name: USER_SERVICE_TOKEN
          value: "{{ .token }}"

# Notes about this workload.yaml structure:
# 1. This file gets converted to a Workload Custom Resource (CR) by choreoctl
# 2. The 'endpoints' array becomes a map with endpoint names as keys
# 3. The 'connections' array becomes a map with connection names as keys
# 4. Schema files (openapi.yaml, schema.graphql, service.proto) are read and inlined
# 5. Template variables in connection values are resolved at runtime by the platform
